% LaTeX Template for short student reports.
% Citations should be in bibtex format and go in references.bib
\documentclass[a4paper, 12pt]{article}
\usepackage[top=2cm, bottom=3cm, left = 2cm, right = 2cm]{geometry} 
\geometry{a4paper} 
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{graphicx} 
\usepackage{amsmath,amssymb}  
\usepackage{bm}  
\usepackage{memhfixc} 
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{booktabs}
\usepackage{xepersian}
\settextfont[Scale=1.]{HM FNazli}
\setlatintextfont[Scale=.9]{Noto Sans}
\pagestyle{fancy}

\title{\lr{Chord: A Scalable Peer-to-peer Lookup Service for Internet
Applications}}
\author{حسین افکار}
%\date{}

\begin{document}
\maketitle
یکی از مشکلات اصلی برنامه‌های
\lr{peer to peer}
شناسایی بهینه نود‌های مورد نیاز است.
پروتکلی که در این مقاله معرفی شده است یک کار را انجام می‌دهد،
که این کار این است که یک کلید را به یک داده در نود دیگر وصل می‌کند.
این پروتکل وقتی که نود‌های دیگر به سیستم اضافه می‌شوند نیز خودش را به صورت بهینه هماهنگ می‌کند. \\
این پروتکل برای این طراحی شده‌است که بتواند مسیر‌یابی بهینه را انجام دهد و همچنین بتواند
\lr{fault tolerance}
را در سیستم‌های توزیع شده پیاده‌سازی کند.
این پروتکل به صورت یک توپولوژی حلقه پیاده‌سازی می‌شود که هر نود در آن مسئول بازه‌ای
از کلید‌ها است.
زمانی که نودی بخواهد یک عمل جستجو یک کلید را انجام دهد ابتدا باید تعیین کند
کدام نود در توپولوژی حلقه مسئول آن کلید است.
این کار با استفاده از تکنیک
\lr{Consistent Hashing}
انجام می‌شود که در آن کلید‌ها به نود‌ها نگاشت می‌شوند.
وقتی که نود مسئول شناسایی شد می‌توانیم داده‌ها را از آن استخراج کنیم.
برای اینکه مسیر‌یابی را بهبود ببخشیم هر نود یک
\lr{finger table}
که در آن اطلاعات نود‌های دیگر در رینگ است را نگه می‌دارد.
این به نودی که اطلاعات را دریافت می‌کند کمک می‌کند که مسیر بعدی را به راحتی تعیین کند.
برای اینکه
\lr{Fault Tolerance}
را بهبود بخشیم این پروتکل در هر نود کپی‌های مختلفی از یک کلید و داده‌هایش را نگه‌داری می‌کند.
این مقاله سه ایده اصلی را مطرح می‌کند که اولی این است که سیستم‌های
\lr{P2P}
فعلی برای سیستم‌های توزیع شده بهینه نشده‌اند و اور‌هد زیادی را بر سیستم تحمیل می‌کنند.
دوم این است که طراحی جدیدی ارائه شده است که این طراحی برای
\lr{Scalability}
و
\lr{Fault Tolerance}
بهینه شده است.
سوم اینکه کارآیی این پروتکل از سیستم‌های فعلی بهتر است.
مزایا و معایب این مقاله به صورت زیر لیست شده است.
\begin{itemize}
    \item اسکیل‌شدن: این پروتکل به صورت بهینه برای سیستم‌های توزیع شده طراحی شده است
    \item کارآیی: این سیستم به خاطر مسیر‌یابی مؤثر کارآیی و عمکرد مفیدی دارد
    \item تحمل خطا: این سیستم با تعیین نود‌های پشتیبان به تحمل خطا کمک می‌کند.
    \item این پروتکل می‌تواند در بخش‌های مختلفی از سیستم‌های توزیع شده استفاده شود.
    \item پیچیدگی: این پروتکل با استفاده از الگوریتم‌های پیچیده پیاده‌سازی شده‌است.
    \item سربار این سیستم قابل توجه است که ممکن است کارآیی را تحت تأثیر قرار دهد.
\end{itemize}
در کل این مقاله یه روش قابل
\lr{Scale}
برای ارتباط
\lr{P2P}
برای سیستم‌های توزیع شده ارائه می‌دهد.
این روش ممکن است که سرباری به سیستم اضافه کند ولی این سربار با توجه به مزایای بالا
قابل چشم پوشی است.
همچنین در شرایط عادی سربار گشتن دنبال کلید در هر نود از اوردر
\lr{$O(logn)$}
می‌باشد و سربار آپدیت کردن جدول مسیر‌یابی
\lr{$O(log^2n)$}
می‌باشد که سربار خوبی از لحاظ استاندارد ساختمان‌داده‌ای محسوب می‌شود.
به طور کلی مقاله رویکرد طراحی را در پیش گرفته و مسائل زیادی را نیز در نظر گرفته و است
و نتایج نشان می‌دهد که این طراحی می‌تواند به راحتی اسکیل شده و طبق شکل ۸ این سیستم تا ۴۵۰ نود
نیز را به راحتی ساپورت می‌کند.
طبق نظر نویسندگان این پروتکل به دلیل سادگی و اسکیل‌پذیری می‌تواند نقش مهمی را در سیستم‌های
توزیع شده بازی کند.
% \bibliography{references}  % need to put bibtex references in references.bib 
\end{document}
