% LaTeX Template for short student reports.
% Citations should be in bibtex format and go in references.bib
\documentclass[a4paper, 12pt]{article}
\usepackage[top=2cm, bottom=3cm, left = 2cm, right = 2cm]{geometry} 
\geometry{a4paper} 
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{graphicx} 
\usepackage{amsmath,amssymb}  
\usepackage{bm}  
\usepackage{memhfixc} 
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{booktabs}
\usepackage{xepersian}
\settextfont[Scale=1.]{HM FNazli}
\setlatintextfont[Scale=.9]{Noto Sans}
\pagestyle{fancy}

\title{یک دیدگاه صنعتی در مورد درک مشترک آکادمیک از سیستم های \lr{mixed-criticality}}
\author{حسین افکار}
%\date{}

\begin{document}
\maketitle
% \tableofcontents

\section{مقدمه}
در سال‌های اخیر صنعت به اجرای برنامه‌ها با سطوح
\lr{criticality}
مختلف بر روی سیستم‌های مالتی‌کور توجه ویژه‌ای نشان داده‌است که این توجه ویژه باعث
شده است که سرمایه‌گزاری‌هایی بر روی پروژه‌های مختلف در بخش‌های
\lr{R\&D}
و
آکادمی انجام بشود.
در این مقاله مدلی که توسط
\lr{vestal}
پیشنهاد داده شده‌است بررسی می‌گردد. این مدل نتیجه ترکیب الزامات سیستم‌های
\lr{hard real-time}
با ایده
\lr{criticality}
است.
اضافه کردن این قید‌ها به سیستم باعث شده‌است که نتایج تئوری زمان‌بندی نیاز به بازسازی و صحت‌سنجی
دوباره داشته باشند.
از زمان به وجود آمدن این ایده به تدریج این مدل با استفاده از لول های مختلف
\lr{criticality}
و پیش‌بینی
\lr{WCET}
پیچیده‌تر شده‌است
ایده‌های اصلی این مقاله عبارت‌اند از
\begin{itemize}
    \item یک بررسی کاربردی و برداشتی از استاندارد‌های ایمنی در صنعت که کامل‌کننده کار 
    \lr{Burns and Davids}
    است
    \item شناسایی نکات مهم و قابل‌توجه برای طراحی سیستم‌های 
    \lr{MCS}
    با قابلیت گرفتن تصدیق‌نامه از استاندارد مورد‌نظر
\end{itemize}
\section{ایده‌ها و خلاصه مقاله}
مفهوم
\lr{criticality}
در استاندارد‌های صنعتی بیشتر به
\lr{safety critical}
بودن ربط پیدا می‌کند
برای اینکه ایمنی یک سیستم
\lr{safety critical}
سنجیده شود یک روند سنجش ایمنی باید حین چرخه توسعه انجام شود و
\lr{failure}
های سیستم را دسته‌بندی کند.
آنالیز امن بودن سیستم با آنالیز مخاطره شروع می‌شود. بعد از آن آنالیز خطا‌هایی که این مخاطره‌ها
را باعث می‌شوند، شروع می‌شود.
شناخته‌شده‌ترین تکتیک‌های شناسایی خطا 
\lr{FTA}
و
\lr{FMEA}
هستند.
\lr{FTA}
و
\lr{FMEA}
دو روش مکمل یکدیگر هستند که در قسمت ۳.۲ استاندارد
\lr{ARP4761}
بیشتر بررسی شده‌اند.
ارزیابی امن بودن در سطح نرم‌افزار، به خصوص در سیستم‌های
\lr{MCS} 
نقش اساسی را بازی می‌کند.
\lr{criticality}
برنامه‌ها باید توسط روش‌های بررسی خطا مانند
\lr{FTA}
یا
\lr{FMEA}
بررسی گردد که این بررسی باعث می‌شود مشارکت این خطا‌های نرم‌افزاری در مخاطرات سیستم مشخص
شود.
آنالیز مخاطره‌های نرم‌افزاری یک روش بالا‌به‌پایین است که توصیه‌هایی را برای از بین‌بردن یا کنترل مخاطره‌های
نرم‌افزاری ارائه می‌کند و این مخاطره‌ها را به رابط‌های بین سیستم و نرم‌افزار ربط می‌دهد.
در شکل ۱ مقاله یک روند
\lr{FMEA}
نرم‌افزاری خلاصه شده‌است که از ۴ مرحله تشکیل شده‌است
\begin{itemize}
    \item مرحله اول: انجام آنالیز از کاربرد‌های سیستم
    \item مرحله دوم: آنالیز دلایل خطا در بخش‌های مختلف سیستم
    \item مرحله سوم: طبقه‌بندی شدت خطا‌ها
    \item مرحله چهارم: اقدامات جبرانی در صورت بروز خطا
\end{itemize}
درجه تضمین توسعه الزامات درستی‌یابی و صحت‌سنجی سیستم را تعیین می‌کند.
هر‌چه‌قدر درجه تضمین توسعه سیستم بالاتر باشد تعداد فعالیت‌های تضمینی بیشتر می‌شود که هزینه
توسعه را افزایش می‌دهد.
تحت استاندارد
\lr{DO-178C}
پنج مرحله شدت تعریف شده‌است
\begin{itemize}
    \item فاجعه: خرابی‌هایی که باعث می‌شود که هواپیما سقوط کند یا کشته بدهد.
    \item خطرناک: خرابی‌هایی که باعت جراحت شدید یا کشنده در تعدادی از سرنشینان شود
    \item عمده: خرابی‌هایی که کارآیی و توانایی هواپیما و یا خدمه را در مواجعه با شرایط نامطلوب
    کاهش می‌دهد 
    \item جزئی: خرابی‌هایی که امنیت هواپیما را به طور قابل توجه کاهش نمی‌دهند
    \item بدون اثر: خرابی‌هایی که اثری بر روی امنیت نمی‌گذارند
\end{itemize}
استاندارد
\lr{IEC61508}
ایده
\lr{system safety function}
را تعریف می‌کند. این تابع توسط یک سیستم برای حفظ حالت امن سیستم تعبیه می‌شود تا
وقتی یک مخاطره رخ می‌دهد بتواند حالت سیستم را حفظ کند.
برای این کار ایده
\lr{safety integrity}
تعریف می‌شود که به احتمال اینکه یک سیستم بتواند توابع امنیت را در تمام حالت‌های سیستم و در یک
پریود خاص انجام دهد، اشاره می‌کند.
چهار سطح برای
\lr{safety integrity levels}
تعریف شده‌است. هر چه سطح بالاتر باشد احتمال اینکه اجرای تابع با خطا روبه‌رو بشود کمتر می‌شود.
استاندارد
\lr{IEC61508}
ارتباط شدت خرابی و سطوح
\lr{SIL}
را با هم مشخص نمی‌کند و آن را به طراح واگذار می‌کند \\
استاندارد
\lr{ISO26262}
از استاندارد
\lr{IEC61508}
ایده می‌گیرد و این سطوح را برای صنعت اتومبیل‌رانی به عنوان
\lr{ASIL}
مشخص می‌کند.
مانند استاندارد
\lr{IEC61508}
این سطوح چهارگانه هستند که حرف
\lr{D}
سخت‌گیرانه ترین سطح و حرف
\lr{A}
کمترین سخت‌گیری را مشخص می‌کنند.
هر چه سطح
\lr{ASIL}
بالاتر باشد نیاز برای کاهش ریسک بیشتر می‌شود.
در جدول ۱ در مقاله این سطوح خطر برای سیستم های اتومبیل‌رانی مشخص شده‌است.
در این جدول از سه پارامتر شدت، احتمال در معرض قرار گرفتن، و کنترل‌پذیری استفاده شده است.
که در این استاندارد پارامتر کنترل‌پذیری به 
\lr{SIL}
اضافه شده است.
برای تخصیص دادن سطوح
\lr{DAL}
و
\lr{SIL}
نیاز است که فرق بین سیستم های
\lr{safety-critical}
،
\lr{mission-critical}
و
\lr{non-critical}
مشخص شود.
یک سیستم
\lr{safety-critical}
سیستمی است که در صورت وقوع خطا باعث مرگ یا خسارات شدید به محیط بشود.
در این کنار در سیستم های
\lr{mission-critical}
سیستم‌هایی هستند که بروز خطا در آن‌ها باعث از دست رفتن سیستم بدون ایجاد خطر به محیط و انسان
می‌شود.
در آخر سیستم‌های
\lr{non-critical}
سیستم‌هایی هستند که در بدترین شرایط خطا، عواقب حداقلی خواهند داشت که عملیات سیستم را تحت
تاثیر قرار نمی‌دهند. \\
طبق گفته این مقاله سیستم‌های
\lr{mixed-criticality}
، سیستمی است که در آن برنامه‌هایی با سطوح تضمین توسعه متفاوت در حال اجرا هستند
که از منابع مشترک استفاده می‌کنند و با این وجود خصوصیات ایمنی خود را که در سیستم برای آن‌ها
تعبیه شده‌است را حفظ می‌کنند. \\
در این مقاله سه استاندارد
\lr{IEC61508}
،
\lr{ISO26262}
و 
\lr{DO-178C}
بررسی شده‌اند.
استاندارد
\lr{DO-178C}
برای سیستم‌های هوایی است. دو بخشی که به ایمنی طراحی نرم‌افزاری می‌پردازند عبارت‌آند از
پارتیشن‌بندی، افزونگی، و مانیتورینگ ایمنی. \\
برای پارتیشن بندی باید موارد زیر در نظر گرفته شوند.
\begin{itemize}
    \item دامنه و حد انزوای اجزای یسیستم نسبت به یکدیگر
    \item چگونگی انزوای اجزای یسیستم نسبت به یکدیگر
\end{itemize}
پنج پیش‌نیاز باید برای مطمئن شدن از درستی ایده پارتیشن‌بندی در سیستم در‌نظر گرفته شوند.
\begin{itemize}
    \item کد، ورودی و خروجی، و محفظه داده‌ای نباید توسط پارتیشن‌های دیگر تغییر داده شوند
    \item نرم‌افزار فقط باید در وقت مقرر شده توسط زمان‌بند از پردازشگر استفاده کند
    \item هر خطا باید درون پارتیشن خودش بماند
    \item نرم‌افزاری که پارتیشن بندی را محقق می‌سازد باید از
    \lr{DAL}
    بالاتری نسبت به بقیه برخوردار باشد
    \item باید سنجش ایمنی بر روی سخت‌افزار انجام شود تا بخشی از آن در صورت خطا بر‌روی سیستم
    تاثیر نگذارد
\end{itemize}
همچنین طبق استاندارد باید سه موضوع زیر بر روی بحث مانیتورینگ در‌نظر گرفته شوند
\begin{itemize}
    \item \lr{DAL}
    مانیتورینگ بالاترین سطح شدت خطا را در سیستم دارد
    \item مانیتور در تمامی شرایط باید خطا را در سیستم تشخیص دهد
    \item استقلال بین مانیتور و اجزای تحت نظر باید حفظ شود
\end{itemize}
استاندارد
\lr{IEC61508}
یک استاندارد عمومی برای ایمنی در صنعت است که یک پایه برای دیگر استاندارد‌ها فراهم می‌سازد.
که در آن مسائل مختلفی بررسی شده است
برای شروع مبحث پارتیشن‌بندی مانند استاندارد
\lr{DO-138C}
نیز در نظر گرفته شده‌است.
دو راه‌حل مجازی و فیزیکی برای پارتیشن‌بندی توسط این استاندارد پیشنهاد شده است.
این استاندارد از دو بعد زمانی و مکانی برای استقلال در پارتیشن‌بندی رونمایی می‌کند
بعد مکانی یعنی داده‌ها نباید توسط برنامه دیگری تغییر یابند و بعد زمانی
به این منعنی است که هیچ برنامه‌ای نباید با بلاک کردن و یا استفاده بیش از حد از پردازنده
مانع اجرای دیگری شود.
برای بدست آوردن استقلال مکانی استاندارد پیشنهاد می‌دهد که از تکنیک‌های زیر استفاده شود.
\begin{itemize}
    \item حفاظت از حافظه سخت‌افزاری\
    \item حافظه مجازی
    \item دیزاین سخت‌گیرانه و آنالیز کد و فایل‌های آبجکت
    \item حفاظت نرم‌افزاری از نرم‌افزار‌های با یکپارچکی بالا
\end{itemize}
همچنین برای استقلال زمانی تکنیک‌های زیر معرفی می‌گردند.
\begin{itemize}
    \item استفاده از زمان‌بند‌های 
    \lr{deterministic}
    \item استفاده از زمان‌بند‌ها با حفظ اولویت سخت‌گیرانه
    \item استفادهاز فنس‌های زمانی برای اتمام برنامه‌ای که از زمان خود تخطی کرده‌است
    \item استفاده از الگوریتم‌های اشتراک زمانی
\end{itemize}
همچنین این مقاله ایده
\lr{Diverse Monitor}
را مطرح می‌کند که در این ایده معماری یک تکنیک طراحی بیان شده‌است که به سیستم اجازه می‌دهد
تا وارد حالت‌های ناایمن نشود. این  ایده یک مانیتور خارجی را در یک سخت‌افزار خارجی اجرا می‌کند که
در صورت بروز خطا می‌تواند یک رویداد مانند به صدا درآوردن یک آلارم را شروع کند. \\
تکنیک دیگری که بررسی شده است تکنیک
\lr{Dynamic Reconfiguration}
است.
هدف این تکنیک این است که در صورت بروز خطای داخلی سیستم را سرپا نگه‌دارد. \\
یک تکنیک دیگر
\lr{Graceful Degradation}
است که سعی می‌کند عملکرد‌های مهم سیستم را در صورت بروز خطا با کم کردن و خاموش کردن
قابلیت‌های غیرضروری سرپا نگه دارد.
آخرین ایده مطرح شده در این استاندارد ایده
\lr{Response Timing and Memory Constraints}
است که در آن تقاضای زمانی و حافظه‌ای سیستم در حالات میانگین و بدترین حالت بررسی شده
تا از رعایت الزامات سیستم اطمینان حاصل شود. \\
استاندارد آخری که در این مقاله مطرح شده استاندارد
\lr{ISO26262}
است که استاندارد
\lr{IEC61508}
را به صنعت اتومبیل‌رانی تعمیم می‌دهد که این استاندارد در مطالب بالا با دو استاندارد قبلی مشترک است. \\
در بخش بعدی این مقاله به دستورالعمل‌های مورد استفاده در صنعت اشاره شده است که تعمیم‌دهنده استاندارد‌های
قبلی هستند.
دستور‌العمل اول به نام
\lr{ARINC-653}
هدف اصلی این دستورالعمل این است که یک رابط عمومی بین نرم‌افزار‌های هوایی و سیستم‌عامل درست کند.
این رابطه با نام
\lr{APEX}
شناخته می‌شود.
مورد اولی که در این دستورالعمل بحث می‌شود بحث پارتیشن‌بندی است.
برای
\lr{deterministic}
کردن این روش طبق این دستورالعمل باید پارتیشن‌ها طبق یک زمان‌بند ثابت بر‌پایه سایکل
زمان‌بندی شوند. همچنین حافظه نیز باید طبق نیاز سیستم از پیش به پارتیشن تخصیص داده شود.
مورد دوم دستورالعمل مدیریت پردازه است. در این دستورالعمل پردازه به عنوان یک تسک در یک
پارتیشن شناخته می‌شود.
درون هر پارتیشن یک اولویت ثابت به هر تسک داده می‌شود. و همچنین در این مدل باید یک روش
امن برای استفاده از منابع مشترک سیستم نیز تعبیه شود و کد‌ها نیر باید فقط در محیط کاربر
اجرا شوند. \\
ایده بعدی در مورد
\lr{Memory Allocation}
است.
در سیستم پیشنهادی 
\lr{Memory Allocator}
های دینامیک در دسترس نیستند و این کار آفلاین و قبل از اجرای سیستم صورت می‌گیرد
همچنین داده‌ها باید در بافر‌ها بین تسک‌های مختلف یک پارتیشن انتقال یابند. \\
ایده چهارم این دستورالعمل ایده ارتباط میان پارتیشن‌ها است که توسط بافر‌ها، بلک‌بورد‌ها، و سمافور‌ها
عملی می‌شود.
ایده پنجم ارتباط در درون پارتیشن‌است که با استفاده از مفهوم چنل‌ها و پیغام‌ها عملی می‌شود.
ایده آخر مدیریت زمان است که به سیستم کمک می‌کند تا زمان‌بندی، دیدن ددلاین‌ها، و تاخیر‌ها را در
سیستم تحقق بخشد. زمان در هر پارتیشن به صورت یکتا وجود دارد و مستقل است. \\
دستورالعمل بعدی
\lr{AUTOSAR}
است که توسط سازندگان قطعات به کار برده شده‌است.
این استاندارد رابط نرم‌افزاری بین قسمت‌‌های مختلف سیستم برای در کنار هم‌قرار گرفتن را تعیین می‌کند.
شکل شماره ۲ در این مقاله لایه‌های مختلف این استاندارد را نشان می‌دهد که به شرح زیر‌ هستند
\begin{itemize}
    \item \lr{Basic Software}
    که سرویس‌های مختلف را در اختیار بخش‌های کاربردی سیستم قرار می دهد
    \item \lr{Runtime Environment}
    این بخش ارتباطات میان و درون پارتیشنی سیستم را مشخص می‌کند
    \item{Software Component}
    که این بخش از بخش‌های یکپارچه‌ای تشکیل شده‌است که هر کدام بخشی از برنامه را پیاده‌سازی می‌کنند
\end{itemize}
همچنین این استاندارد یک سیستم‌عامل بی‌درنگ با زمان‌بندی اولویت‌ثابت قبضه‌پذیر با پشتیبانی
از سیستم‌های مالتی‌کور را مشخص می‌کند.
قسمت‌های از این سیستم‌عامل که به مبحث
\lr{MCS}
مربوط می‌ شوند شامل پارتیشن‌بندی زمانی، پارتیشن‌بندی مکانی، و ارتباطات بین برنامه‌ها می باشد. \\
در بخش پارتیشن‌بندی زمانی الزام می‌شود که هیچ خطای زمانی به برنامه‌های دیگر منتشر نشود.
یک خطای زمانی یا روتین وقفه زمانی اتفاق می‌افتد که یا از زمان اجرای مشخص تخطی شده‌ ‌باشد
یا اینکه زمان مشخص ورود تسک به سیستم رعایت نشده‌باشد.
برای این کار باید سه موضوع زیر را رعایت کنیم
\begin{itemize}
    \item جلوگیری از خطا‌های زمانی تسک‌ها و روتین‌های وقفه توسط \lr{execution time protection}
    \item جلوگیری از خطا‌های‌ زمانی تسک‌ها و روتین‌های وقفه که باعث آن قفل کردن منابع
    توسط تسک‌های با الویت پایین‌تر است با استفاده از \lr{locking time protection}
    \item جلوگیری از خطا‌های زمانی که باعث‌ آن ریت رسیدن تسک‌ها و روتین‌های وقفه است با استفاده ازذ \lr{inter-arrival time protection} 
\end{itemize}
موضوع بعدی پارتیشن‌بندی مکانی است که از حافظه در برابر دسترسی‌های غیر‌مجاز مراقبت می‌کند.
که طبق این الزام باید از استک، محل ذخیره داده‌ها، و محل قرارگیری دستورالعمل‌ها مراقبت کنیم.
مورد آخر ارتباط میان برنامه‌ها است که این استاندارد یک مکانیزم به نام
\lr{IOC}
برای انجام این کار ارائه می‌دهد. \\
در بخش شش این مقاله تمرکز روی یک مدل از آکادمی در بحث
\lr{MCS}
گذاشته شده است.
بیشتر کاری که در این زمینه انجام شده است برپایه مدل
\lr{Vestal}
می‌باشد.
مدل وستال در نظر می‌گیرد که سیستم  ۱ تا
\lr{L}
حالت اجرا دارد.
که در این سیستم هر تسک
$\tau_i$
یک پریود و ددلاین دارد و همچنین یک سطح اطمینان دارد و یک مجموعه از
\lr{WCET}
ها که به فرم
$\{C_{i,1},C_{i,2},...,C{i,l_i}\}$
است که فرض می‌کنیم اندیس کوچکتر معادل با زمان کمتر است.
وستال طبق این شرط زمان‌بندی را برای سیستم بررسی کرد و یک اولویت‌بندی برای تسک‌های این سیستم
ارائه نمود.
برای ساده‌سازی این مدل از دو لول اطمینان استفاده می‌شود که به آن‌ها مد
\lr{LO}
و
\lr{HI}
می‌گویند.
در فهم عبارت
\lr{system critical}
یک سؤتفاهم بین استاندارد‌های صنعتی و آکادمی وجود دارد که از این عبارت برای نشان دادن
مود‌های اجرای تسک‌ها استفاده می‌کنند در صورتی که صنعت از این عبارت برای نشان دادن
درجه اطمینان استفاده می‌کند.
عبارت دیگر کلمه
\lr{function}
سطوح مختلف
\lr{SIL}
باعث می‌شود که کد‌ها شکل دیگری به خود بگیرند. استاندارد پیشنهاد می‌کند که برای
\lr{SIL}
های بالاتر روش‌های سخت‌گیرانه تری برای محاسبه
\lr{WCET}
استفاده شود که از لحاظ ایمنی بهتر است از یک تقریب دقیق‌تر برای محاسبه
\lr{WCET}
استفاده کنیم تا در صورت وقوع
\lr{overshooting}
کمترین تاثیر را بر روی ایمنی سیستم بگذاریم.
مهم‌تر از پیش‌بینی
\lr{WCET}
این است که اجازه ندهیم ایمنی سیستم در صورت استفاده بیش از حد از منابع پردازشگر
تحت تاثیر قرار بگیرد. \\
\lr{Graceful Degradation}
تکنیکی است که در قسمت ۴.۲.۴ مقاله به آن پرداخته شد. طبق گفته این مقاله تصمیم اینکه کدام تسک
کم اهمیت برای کدام تسک پر اهمیت قربانی شود نیازمند این است که یک بررسی در حین طراحی
انجام شود. \\
در بخش ۷ این مقاله یک خلاصه از روش‌های و مشخصات کلیدی برای طراحی یک سیستم
\lr{MCS}
در جدول زیر آورده شده‌است
\begin{table}[H]
    \centering
    \begin{tabular}{lp{13cm}l}
        \toprule
        ایده & شرح \\
        \cmidrule(r){1-1}\cmidrule(lr){2-2}
        بودجه زمانی & تسک‌ها نباید از بودجه تخصیص داده شده تخطی کنند \\
        \lr{inter-arrival rate} & تسک‌ها باید به نرخ رسیدن خود احترام بگذارند \\
        حفاظت در مقابل خطای زمانی & هر خطای زمانی نباید بر روی تسک‌های دیگر تاثیر بگذارد \\
        درجه اطمینان نرم‌افزار مقسم زمان & این نرم‌افزار باید با بیشترین درجه اطمینان طراحی شود \\
        انزوای منطقی & هر تسک در سیستم نباید حافظه تسک‌های دیگر را تغییر دهد \\
        حفاظت سخت‌افزاری &  برای اینکه از انزوای پارتشین‌ها مطمئن شویم باید از روش‌های حفاظت سخت‌افزاری استفاده کنیم \\
        اشتراک منابع بین پارتیشنی & پروتکل اشتراک منابع باید دسترسی به منابع را مشخص و در بازه زمانی مورد نظر نگه‌دارد \\
        اشتراک منابع درون پارتیشن & پروتکل اشتراک منابع باید دسترسی به منابع را مشخص و در بازه زمانی مورد نظر نگه‌دارد \\
        منقضی شدن بودجه منابع & تسکی که بودجه منابع آن منقضی شده‌است تا وقتی که دوباره بودجه به آن تخصیص نگیرد نمی‌تواند درخواست منابع کند \\
        عوض کردن مد فعالیت & یک سیستم باید اجازه داشته باشه بدون به خطر انداختن ایمنی مد اجرایی خود را عوض کند \\
        \lr{safe graceful degradation} & سیستم باید اجازه داشته باشد که بین مد‌های اجرایی تنزل درجه پیدا کند و در صورت نیاز تسک‌های غیرضروری برای انجام عملیات ایمن را خاموش کند \\
        تعلیق تسک‌ها & اینکه چه تسک‌هایی می‌تواند در صورت وجود خطا تعلیق شوند باید در زمان طراحی مشخص شود \\
        آنالیز خطا & آنالیز خطا به منظور شناسایی تمامی دلایل احتمالی شکست در سیستم باید انجام شود \\
        مانیتور درجه اطمینان کار‌ها & بخش مانیتورینگ باید با بالاترین درجه اطمینان از خطا و شدت خطا طراحی شود \\
        انزوای مانیتور و توابع مانیتور شده & مانیتور نباید از خطا‌های توابع مانیتور شده تاثیر بپذیرد \\
        شناسایی خطا‌های زمانی & اگر یک خطای زمانی در تسک اتفاق بیوفتد سیستم‌عامل باید این را شناسایی کند و یک رویداد سطح برنامه را برای این خطا شروع کند \\
        \bottomrule
    \end{tabular}
    \caption{ماتریس ردیابی}
    \label{table:1}
\end{table}
بخش ۸ در این مقاله به موضوع راه‌حل‌ها و مشکلات باز مطرح شده در آکادمی می‌پردازد.
هدف از این کار این است که نیازمندی‌های سیستم‌های
\lr{MCS}
را به راه‌حل‌های موجود در آکادمی نگاشت کند. \\
موضوع اول در مورد رزرو کردن منابع است.
روش اول معرفی شده روش
\lr{Hierarchical Scheduling}
است که این تکنیک اثرات تخطی کردن از لیمیت زمانی برای برنامه‌ها با زمان محاسبات متغیر را کم می‌کند.
در این روش از ایده یک سرور که با دو متغیر
$(Q_i,P_i)$
استفاده می‌شود که
$Q_i$
بودجه سرور و
$P_i$
زمان پرشدن دوباره منابع سیستم است. \\
ویژگی مثبت روش این است که انزوای هر تسک در پردازشگر تضمین می‌شود و ددلاین‌های یک تسک
بر روی تسک‌های دیگر بر سرور دیگر تاثیر نمی‌گذارد.
باوجود اینکه این روش برای مواقعی که سیستم از تسک‌های
\lr{hard, soft}
، و 
\lr{non-realtime}
تشکیل شده است کارایی دارد، اگر در محاسبات بودجه سرور دقت کافی نشود و برای یک تسک بیش
از حد کوچک باشد می‌تواند باعث شود که تسک ددلاین خود را نبیند.
همچنین اگر بودجه داده شده به تسک بیش از حد باشد ممکن است سیستم در شرایطی کم استفاده بماند.
روش دوم زمان بعدی
\lr{Time-triggered Scheduling}
می‌باشد که در این روش زمان‌بندی آفلاین انجام شده و تسک‌ها یک زمان از پیش تعیین شده را دراختیار
دارند. چالش اصلی این روش این است که یک زمان‌بندی که ایمنی همه تسک‌ها را رعایت می‌کند
را در اختیار سیستم قرار دهد. \\
موضوع دوم در مورد زمان‌بندی چند حالته است.
به سیستمی که در آن تسک‌ها به خاطر شرایط فیزکی سیستم ممکن است تغییر یافته یا عوض‌شوند و در
مود‌‌های مختلف دسته‌بندی شوند سیستم مالتی مود گفته می‌شود.
یکی از چالش‌های این روش در مورد زمان تغییر مود تسک‌ها از جدید به قدیم است
که یک حالت گذار را در سیستم به‌وجود می‌آورد که ممکن است در این حالت گذار سیستم قابل زمان‌بندی
نباشد.
در سال‌های اخیر محققان توانسته‌اند برای مدل وستال روش‌های آنالیزی را ارائه دهند که می‌تواند
تعیین کند که تسک‌ها در صورت تغییر مود الزامات زمانی را رعایت می‌کنند یا نه. \\
موضوع سوم در مورد مدل الاستیک تسک است.
که در این چهارچوب تسک‌ها می‌توانند زمان اجرای خود را بر اساس بار روی سیستم عوض کنند. \\
موضوع چهارم پروتکل‌های اشتراک منابع است.
در بخش‌های پیش گفته شد که یک سیستم
\lr{MCS}
که با استاندارد همخوانی دارد باید به تیم تولید نرم‌افزار اجازه بدهد که بتوانند نرم‌افزار‌هایی تولید کنند
که در کنار یکدیگر یک سیستم کامل را تشکیل بدهند.
موضوع کنترل منابع برای سیستم‌های تک هسته‌ای به خوبی تثبیت‌شده است. وقتی
\lr{Hierarchical Scheduling}
وارد مساله می‌شود این موضوع به‌ دلیل امکان وجود انسداد بین دو پردازه پیچیده خواهد‌شد.
که این مقاله در بخش \lr{8.4} چهار راه‌حل موجود در مقالات را برای این مورد پیشنهاد می‌دهد. \\
موضوع پنجم موضوع
\lr{Runtime Verification}
می‌باشد که این ایده الزامات سیستم و بخش‌های آن در زمان اجرا رعایت می‌شوند. \\
موضوع ششم تخصیص یک نرخ خرابی در نرم‌افزار است.
که جدیدا در تحقیقات انجام شده در این موضوع ایده
\lr{Probabilistic WCET}
مطرح شده است که در آن به
\lr{WCET}
به عنوان یک عدد ثابت نگاه نمی‌شود.
که ایده اصلی در این موضوع این است که اگر احتمال تخطی از
\lr{WCET}
کوچکتر از احتمال وقوع خطا باشد آنگاه عدد
\lr{WCET}
یک تقریب خوب برای سیستم می‌باشد. \\
در ادامه این مقاله در مورد موضوعات باز در این زمینه صحبت می‌کند که دو موضوع باز در این زمینه
را مطرح کرده‌است.
موضوع اول ادغام
\lr{Hierarchical Scheduling}
و
\lr{Multi-Mode Change}
است که برای اینکار باید امکان زمان‌بندی سیستم برای انواع مد‌ها و حالات گذار‌ مد‌ها بررسی شود.
مورد دوم ادغام
\lr{Multi-Mode Change}
و پروتکل‌های اشتراک منابع است که مشابه موضوع قبل باید در حالات گذار مد‌ها قید‌های زمانی نیز
بررسی شوند که به گفته این مقاله این دو موضوع از مطالب باز در این زمینه هستند.

\section{نتیجه گیری و بحث}
در این مقاله موضوعات مربوط به
\lr{MCS}
از جنبه صنعت بررسی شده است. هدف اصلی مقاله این بود که مسائل مربوط به این
سیستم‌ها را برای کسانی که متخصص نیستند بیان کند و اینکه از پخش شدن
فرض‌های غلط جلوگیری شود. \\
در ابتدای‌ این مقاله بررسی اجمالی از استاندارد‌های موجود در صنعت که به
\lr{MCS}
ربط داشتند انجام‌شد. همچنین در مورد فرض‌های غلط و تداخلات معانی بین آکادمی و صنعت
توضیحاتی داده شد.
در این مقاله سعی شده است که ارتباط بین مفهوم ایمنی و
\lr{MCS}
که در صنعت موجود است برقرار شود.
همچنین این مقاله در بخش‌های بعدی شروع به بررسی دستورالعمل‌ها و موضوعات باز در این زمینه کرده
که می‌تواند پایه‌ای برای بحث‌های آینده باشد.
علاوه بر این در بخش های آخر مقاله رفرنس‌های زیادی در بخش‌های مختلف داده شده که برای
بررسی کردن و فهم دقیق موضوع کمک شایانی خواهند کرد. \\
طبق گفته این مقاله پیش‌بینی کردن آینده فراگیری مفهوم
\lr{MCS}
در صعنت سخت می‌باشد ولی صنعت هواپیمایی با احتیاط بیشتری با این موضوع برخورد می‌کند
و در این کنار صنعت اتومبیل‌رانی به دلیل وجود رگولاتوری‌های ساده‌تر در این زمینه
پیشرفت سریع‌تری داشته است.
همچنین به وجود آمدن پلتفرم‌های چند هسته‌ای جا را برای تعبیه الگورتیم‌های
\lr{deterministic}
باز کرده است و همچنین نیاز به کنترل منابع و همچنین الزاماتی که مدل
\lr{MCS}
به سیستم تحمیل می‌کند باعث شده است که مدل‌ها و قید‌های اطراف آن عوض شود و نیاز به این
باشد که مدل‌ها و ایده‌ها آپدیت شده و دوباره صحت‌سنجی شوند.
همچنین به وجود آمدن مدل‌های با چند مد اجرایی باعث شده است که مسائلی در انواع زمینه‌ها
مخصوصا موقع گذار از مد‌ها به وجود بیاید که لازم است مدل‌ها نیز در این مورد نیز آپدیت شده و طبق
گفته مقاله این موضوع در تمامی موضوعات باز این حوزه دخیل می‌باشد.
به طور کلی هدف مقاله این بود که میان مدل‌های مطرح شده در آکادمی و استاندارد‌های صنعتی یکپارچه‌سازی
انجام دهد تا تولید روش‌های و حل مشکلات در این سیستم‌ها سرعت یابند.

\bibliographystyle{abbrv}
% \bibliography{references}  % need to put bibtex references in references.bib 
\end{document}
